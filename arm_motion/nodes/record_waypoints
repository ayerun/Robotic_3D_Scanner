#!/usr/bin/env python3

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import Pose, PoseStamped
from math import pi
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list
from std_srvs.srv import Empty, EmptyResponse, SetBool, SetBoolResponse
from moveit_commander.conversions import pose_to_list
from moveit_msgs.msg import MoveItErrorCodes
from arm_move.srv import Step

class MoveGroupPythonInterface(object):
    def __init__(self):
        super(MoveGroupPythonInterface, self).__init__()

        joint_state_topic = ['joint_states:=/robot/joint_states']
        ## First initialize `moveit_commander`_ and a `rospy`_ node:
        moveit_commander.roscpp_initialize(joint_state_topic)
        
        
        # ## Set the name of the robot
        # self.robot_name = rospy.get_param("~robot_name")

        # ## Set the dof of the robot - this will make sure that the right number of joints are controlled
        # self.dof = rospy.get_param("~dof")

        ## Instantiate a `RobotCommander`_ object. This object is the outer-level interface to
        ## the robot:
        robot = moveit_commander.RobotCommander(robot_description='/robot_description')

        ## Instantiate a `PlanningSceneInterface`_ object.  This object is an interface
        ## to the world surrounding the robot:
        scene = moveit_commander.PlanningSceneInterface()

        ## Instantiate a `MoveGroupCommander`_ object.  This object is an interface
        ## to one group of joints. 
        ## This interface can be used to plan and execute motions on the Interbotix Arm:
        group_name = "right_arm"
        self.group = moveit_commander.MoveGroupCommander(robot_description='/robot_description', name=group_name)


        ## We create a `DisplayTrajectory`_ publisher which is used later to publish
        ## trajectories for RViz to visualize:
        display_trajectory_publisher = rospy.Publisher("move_group/display_planned_path",
                                                        moveit_msgs.msg.DisplayTrajectory,
                                                        queue_size=20)

        # group = self.group

        # ## Getting Basic Information
        # ## ^^^^^^^^^^^^^^^^^^^^^^^^^
        # # We can get the name of the reference frame for this robot:
        # planning_frame = self.group.get_planning_frame()
        # print("============ Reference frame: %s" % planning_frame)

        # # We can also print(the name of the end-effector link for this group:
        # eef_link = self.group.get_end_effector_link()
        # print("============ End effector: %s" % eef_link)

        # # We can get a list of all the groups in the robot:
        # group_names = robot.get_group_names()
        # print("============ Robot Groups:", robot.get_group_names())

        # # Sometimes for debugging it is useful to print(the entire state of the
        # # robot:
        # print("============ Printing robot state")
        # print(robot.get_current_state())
        # print("")

        self.initial_pose = self.group.get_current_pose().pose



    #     self.box_name = ''          # small light object to pick up
    #     self.realsense_name = ''     # realsense box
    #     self.table_name = ''        # table
    #     self.robot = robot
    #     self.scene = scene
    #     self.group = group
    #     self.gripper_group = gripper_group
    #     self.display_trajectory_publisher = display_trajectory_publisher
    #     self.planning_frame = planning_frame
    #     self.eef_link = eef_link
    #     self.group_names = group_names

    #     # Create parameters on ROS parameter server for storing waypoints
    #     self.x = rospy.get_param('/px100/mover/waypoints/x', 0)
    #     self.y = rospy.get_param('/px100/mover/waypoints/y', 0)
    #     self.z = rospy.get_param('/px100/mover/waypoints/z', 0)
    #     # self.gripper_state = rospy.get_param('/px100/mover/waypoints/g', False)

    #     # store all past states
        self.x_list = []
        self.y_list = []
        self.z_list = []
        self.x_o_list = []
        self.y_o_list = []
        self.z_o_list = []
        self.w_o_list = []

        self.x_sent_list = []
        self.y_sent_list = []
        self.z_sent_list = []
        self.x_sent_o_list = []
        self.y_sent_o_list = []
        self.z_sent_o_list = []
        self.w_sent_o_list = []
    #     # self.gripper_state_list = []

    #     ## Add Table (add collision object upon startup)
    #     robot_name = self.robot_name
    #     table_name = self.table_name
    #     scene = self.scene

    #     table_pose = PoseStamped()
    #     table_pose.header.frame_id = robot_name + "/base_link"
    #     table_pose.pose.position.z = -0.025
    #     table_pose.pose.orientation.w = 1.0
    #     table_name = "table"
    #     self.scene.add_box(table_name, table_pose, size=(0.5, 0.5, 0.1))

    #     # Copy local variables back to class variables. In practice, you should use the class
    #     # variables directly unless you have a good reason not to.
    #     self.table_name = table_name
    #     self.wait_for_state_update(box_is_known=True, timeout=4)

    #     self.reset = rospy.Service("reset", SetBool, self.reset_callback)
        self.step = rospy.Service("step", Step, self.step_callback)
        self.follow = rospy.Service("follow", Empty, self.follow_callback)
        self.sawyer_plan = rospy.Service("sawyer_plan", Step, self.sawyer_plan_callback)

    # def wait_for_state_update(self, box_is_known=False, box_is_attached=False, timeout=4):
    #     box_name = self.box_name
    #     scene = self.scene

    #     start = rospy.get_time()
    #     seconds = rospy.get_time()
    #     while (seconds - start < timeout) and not rospy.is_shutdown():
    #         # Test if the box is in attached objects
    #         attached_objects = scene.get_attached_objects([box_name])
    #         is_attached = len(attached_objects.keys()) > 0

    #         # Test if the box is in the scene.
    #         # Note that attaching the box will remove it from known_objects
    #         is_known = box_name in scene.get_known_object_names()
    #         # Test if we are in the expected state
    #         if (box_is_attached == is_attached) and (box_is_known == is_known):
    #             return True

    #         # Sleep so that we give other threads time on the processor
    #         rospy.sleep(0.1)
    #         seconds = rospy.get_time()

    #     # If we exited the while loop without returning then we timed out
    #     return False

    # def reset_callback(self, req):
    #     """ reset service callback
    #         puts a small box (realsense box) into the scene
    #         sets the robot position to home

    #         args:
    #             bool (True to clear waypoints, False to not clear)

    #         returns:
    #             SetBoolResponse
    #     """
    #     print(req.data)
    #     robot_name = self.robot_name
    #     realsense_name = self.realsense_name
    #     scene = self.scene

    #     realsense_pose = PoseStamped()
    #     realsense_pose.header.frame_id = "world"
    #     realsense_pose.pose.position.x = 0.15
    #     realsense_pose.pose.position.y = -0.15
    #     realsense_pose.pose.position.z = 0.025
    #     realsense_pose.pose.orientation.w = 1.0
    #     realsense_name = "realsense_box"
    #     self.scene.add_box(realsense_name, realsense_pose, size=(0.140, 0.09, 0.05))

    #     self.realsense_name = realsense_name
    #     self.wait_for_state_update(box_is_known=True, timeout=4)

    #     # return to home position. Define gripper as open in home position
    #     self.group.set_named_target("Home")
    #     self.group.go()
    #     self.gripper_group.set_named_target("Open")
    #     self.gripper_group.go(wait=True)

    #     if req.data == True:
    #         self.x_list = []
    #         self.y_list = []
    #         self.z_list = []
    #         self.gripper_state_list = []

    #         rospy.set_param('/px100/mover/waypoints/x', self.x_list)
    #         rospy.set_param('/px100/mover/waypoints/y', self.y_list)
    #         rospy.set_param('/px100/mover/waypoints/z', self.z_list)
    #         rospy.set_param('/px100/mover/waypoints/g', self.gripper_state_list)
    #         return SetBoolResponse(True, "waypoints cleared")
    #     else:
    #         return SetBoolResponse(True, "waypoints not cleared")

    def step_callback(self, req):
        """ step service callback
            reads in a user input pose and gripper boolean
            plans a motion path and executes it
            saves the user input points to a waypoints list if planning successful

            args:
                Pose
                bool

            returns:
                MoveitErrorCodes
        """
        current_pose = self.group.get_current_pose().pose
        
        self.x_list.append(current_pose.position.x)
        self.y_list.append(current_pose.position.y)
        self.z_list.append(current_pose.position.z)
        self.x_o_list.append(current_pose.orientation.x)
        self.y_o_list.append(current_pose.orientation.y)
        self.z_o_list.append(current_pose.orientation.z)
        self.w_o_list.append(current_pose.orientation.w)
            # self.gripper_state_list.append(gripper)
        print(self.x_list)
            # update the parameter on parameter server
        rospy.set_param('/waypoints/x', self.x_list)
        rospy.set_param('/waypoints/y', self.y_list)
        rospy.set_param('/waypoints/z', self.z_list)
        rospy.set_param('/waypoints/x_o', self.x_o_list)
        rospy.set_param('/waypoints/y_o', self.y_o_list)
        rospy.set_param('/waypoints/z_o', self.z_o_list)
        rospy.set_param('/waypoints/w_o', self.w_o_list)
            # rospy.set_param('/px100/mover/waypoints/g', self.gripper_state_list)

        return MoveItErrorCodes()

    def follow_callback(self, req):
        """ follow service callback
            executes the path of previously saved waypoints

            returns:
                EmptyResponse
        """
        # x = rospy.get_param('/waypoints/x')
        # y = rospy.get_param('/waypoints/y')
        # z = rospy.get_param('/waypoints/z')
        # rospy.get_param('/waypoints/x_o', self.x_o_list)
        #     rospy.get_param('/waypoints/y_o', self.y_o_list)
        #     rospy.get_param('/waypoints/z_o', self.z_o_list)
        #     rospy.get_param('/waypoints/w_o', self.w_o_list)

        # gripper_state = rospy.get_param('/px100/mover/waypoints/g')


        for i in range(len(self.x_list)):
            p = Pose()
            p.orientation.x = self.x_o_list[i]
            p.orientation.y = self.y_o_list[i]
            p.orientation.z = self.z_o_list[i]
            p.orientation.w = self.w_o_list[i]
            p.position.x = self.x_list[i]
            p.position.y = self.y_list[i]
            p.position.z = self.z_list[i]

            self.group.set_pose_target(p)
            success, traj, p_time, errorcode = self.group.plan()
            self.group.execute(traj, wait=True)
            self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
            self.group.clear_pose_targets()

        return EmptyResponse()

    def sawyer_plan_callback(self, req):
        """ step service callback
            reads in a user input pose and gripper boolean
            plans a motion path and executes it
            saves the user input points to a waypoints list if planning successful

            args:
                Pose
                bool

            returns:
                MoveitErrorCodes
        """
        user_pose = req.pose                                # user-specified pose
        self.group.set_pose_target(user_pose)               # setting ee pose, if one is available
        # Return a tuple of the motion planning results such as
        # (success flag : boolean, trajectory message : RobotTrajectory,
        # planning time : float, error code : MoveitErrorCodes) 
        success, traj, p_time, errorcode = self.group.plan()
        if success != True:
            return errorcode
        else:
            self.group.execute(traj, wait=True)
            self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
            self.group.clear_pose_targets()

            self.x_sent_list.append(user_pose.position.x)
            self.y_sent_list.append(user_pose.position.y)
            self.z_sent_list.append(user_pose.position.z)
            self.x_sent_o_list.append(user_pose.orientation.x)
            self.y_sent_o_list.append(user_pose.orientation.y)
            self.z_sent_o_list.append(user_pose.orientation.z)
            self.w_sent_o_list.append(user_pose.orientation.w)

            print(self.x_list)

            rospy.set_param('/waypoints/x_sent', user_pose.position.x)
            rospy.set_param('/waypoints/y_sent', user_pose.position.y)
            rospy.set_param('/waypoints/z_sent', user_pose.position.z)
            rospy.set_param('/waypoints/x_sent_o', user_pose.orientation.x)
            rospy.set_param('/waypoints/y_sent_o', user_pose.orientation.y)
            rospy.set_param('/waypoints/z_sent_o', user_pose.orientation.z)
            rospy.set_param('/waypoints/w_sent_o', user_pose.orientation.w)

            return errorcode


def main():
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('move_group_python_interface_move_arm', anonymous=True)
    
    mover = MoveGroupPythonInterface()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
