#!/usr/bin/env python3

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import Pose, PoseStamped
from math import pi
from std_msgs.msg import String, Bool, Int16
from moveit_commander.conversions import pose_to_list
from std_srvs.srv import Empty, EmptyResponse, SetBool, SetBoolResponse
from moveit_commander.conversions import pose_to_list
from moveit_msgs.msg import MoveItErrorCodes
from arm_move.srv import Step

class MoveGroupPythonInterface(object):
    def __init__(self):
        super(MoveGroupPythonInterface, self).__init__()
        rospy.loginfo('RUNNING INIT')
        rospy.init_node('record_waypoints', anonymous=True)
        joint_state_topic = ['joint_states:=/robot/joint_states']
        ## First initialize `moveit_commander`_ and a `rospy`_ node:
        moveit_commander.roscpp_initialize(joint_state_topic)
        
        robot = moveit_commander.RobotCommander(robot_description='/robot_description')

        scene = moveit_commander.PlanningSceneInterface()

        group_name = "right_arm"
        self.group = moveit_commander.MoveGroupCommander(robot_description='/robot_description', name=group_name)

        display_trajectory_publisher = rospy.Publisher("move_group/display_planned_path",
                                                        moveit_msgs.msg.DisplayTrajectory,
                                                        queue_size=20)

        self.initial_pose = self.group.get_current_pose().pose

        self.turtle_sub = rospy.Subscriber('/next', String, self.arm_action_callback)
        
        ## store three target positions into waypoints
        self.scan_x = rospy.get_param('/waypoints/x')
        self.scan_y = rospy.get_param('/waypoints/y')
        self.scan_z = rospy.get_param('/waypoints/z')
        self.scan_x_o = rospy.get_param('/waypoints/x_o')
        self.scan_y_o = rospy.get_param('/waypoints/y_o')
        self.scan_z_o = rospy.get_param('/waypoints/z_o')
        self.scan_w_o = rospy.get_param('/waypoints/w_o')
        ## set home pose 
        self.home = Pose()
        self.home.position.x = self.scan_x[0]
        self.home.position.y = self.scan_y[0]
        self.home.position.z = self.scan_z[0]
        self.home.orientation.x = self.scan_x_o[0]
        self.home.orientation.y = self.scan_y_o[0]
        self.home.orientation.z = self.scan_z_o[0]
        self.home.orientation.w = self.scan_w_o[0]
        rospy.loginfo('saved home pose')

        # self.group.set_named_target("Home")
        self.group.set_pose_target(self.home)
        success, traj, p_time, errorcode = self.group.plan()
        # self.group.go()
        self.group.execute(traj, wait=True)
        self.group.stop()                                  
        self.group.clear_pose_targets()
        rospy.loginfo('moved to home')

    #     # store all past states
        self.x_list = []
        self.y_list = []
        self.z_list = []
        self.x_o_list = []
        self.y_o_list = []
        self.z_o_list = []
        self.w_o_list = []

        self.x_sent_list = []
        self.y_sent_list = []
        self.z_sent_list = []
        self.x_sent_o_list = []
        self.y_sent_o_list = []
        self.z_sent_o_list = []
        self.w_sent_o_list = []

        self.reset = rospy.Service("reset", SetBool, self.reset_callback)
        self.step = rospy.Service("step", Step, self.step_callback)
        self.follow = rospy.Service("follow", Empty, self.follow_callback)

        # self.arm_action = rospy.Subscriber('/next', Bool, self.arm_action_callback)
        self.turtle_go = rospy.Publisher('/next', String, queue_size=10)

    def reset_callback(self, req):
        """ reset service callback
            puts a small box (realsense box) into the scene
            sets the robot position to home

            args:
                bool (True to clear waypoints, False to not clear)

            returns:
                SetBoolResponse
        """
        # self.group.set_pose_target(self.home)
        self.group.set_named_target("Home")
        self.group.go()
        # success, traj, p_time, errorcode = self.group.plan()
        self.group.execute(traj, wait=True)
        self.group.stop()                                  
        self.group.clear_pose_targets()
        return SetBoolResponse(True, "Arm at home position")

    def arm_action_callback(self, req):
        rospy.loginfo(req)
        print('ARM ACTION CALLBACK')
        print(req == String('sawyer'))
        if req == String('sawyer'):
            for i in range(len(self.scan_x)):
                p = Pose()
                p.orientation.x = self.scan_x_o[i]
                p.orientation.y = self.scan_y_o[i]
                p.orientation.z = self.scan_z_o[i]
                p.orientation.w = self.scan_w_o[i]
                p.position.x = self.scan_x[i]
                p.position.y = self.scan_y[i]
                p.position.z = self.scan_z[i]

                self.group.set_pose_target(p)
                success, traj, p_time, errorcode = self.group.plan()
                self.group.execute(traj, wait=True)
                self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
                self.group.clear_pose_targets()

            pub = String('turtle')
            self.turtle_go.publish(pub)
        # return True

    def step_callback(self, req):
        """ step service callback
            reads in a user input pose and gripper boolean
            plans a motion path and executes it
            saves the user input points to a waypoints list if planning successful

            args:
                Pose
                bool

            returns:
                MoveitErrorCodes
        """
        current_pose = self.group.get_current_pose().pose
        
        self.x_list.append(current_pose.position.x)
        self.y_list.append(current_pose.position.y)
        self.z_list.append(current_pose.position.z)
        self.x_o_list.append(current_pose.orientation.x)
        self.y_o_list.append(current_pose.orientation.y)
        self.z_o_list.append(current_pose.orientation.z)
        self.w_o_list.append(current_pose.orientation.w)
            # self.gripper_state_list.append(gripper)
        print(self.x_list)
            # update the parameter on parameter server
        rospy.set_param('/waypoints/x', self.x_list)
        rospy.set_param('/waypoints/y', self.y_list)
        rospy.set_param('/waypoints/z', self.z_list)
        rospy.set_param('/waypoints/x_o', self.x_o_list)
        rospy.set_param('/waypoints/y_o', self.y_o_list)
        rospy.set_param('/waypoints/z_o', self.z_o_list)
        rospy.set_param('/waypoints/w_o', self.w_o_list)
            # rospy.set_param('/px100/mover/waypoints/g', self.gripper_state_list)

        return MoveItErrorCodes()

    def follow_callback(self, req):
        """ follow service callback
            executes the path of previously saved waypoints

            returns:
                EmptyResponse
        """
        for i in range(len(self.x_list)):
            p = Pose()
            p.orientation.x = self.x_o_list[i]
            p.orientation.y = self.y_o_list[i]
            p.orientation.z = self.z_o_list[i]
            p.orientation.w = self.w_o_list[i]
            p.position.x = self.x_list[i]
            p.position.y = self.y_list[i]
            p.position.z = self.z_list[i]

            self.group.set_pose_target(p)
            success, traj, p_time, errorcode = self.group.plan()
            self.group.execute(traj, wait=True)
            self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
            self.group.clear_pose_targets()

        return EmptyResponse()

    def sawyer_plan_callback(self, req):
        """ step service callback
            reads in a user input pose and gripper boolean
            plans a motion path and executes it
            saves the user input points to a waypoints list if planning successful

            args:
                Pose
                bool

            returns:
                MoveitErrorCodes
        """
        user_pose = req.pose                                # user-specified pose
        self.group.set_pose_target(user_pose)               # setting ee pose, if one is available
        # Return a tuple of the motion planning results such as
        # (success flag : boolean, trajectory message : RobotTrajectory,
        # planning time : float, error code : MoveitErrorCodes) 
        success, traj, p_time, errorcode = self.group.plan()
        if success != True:
            return errorcode
        else:
            self.group.execute(traj, wait=True)
            self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
            self.group.clear_pose_targets()

            self.x_sent_list.append(user_pose.position.x)
            self.y_sent_list.append(user_pose.position.y)
            self.z_sent_list.append(user_pose.position.z)
            self.x_sent_o_list.append(user_pose.orientation.x)
            self.y_sent_o_list.append(user_pose.orientation.y)
            self.z_sent_o_list.append(user_pose.orientation.z)
            self.w_sent_o_list.append(user_pose.orientation.w)

            print(self.x_list)

            rospy.set_param('/waypoints/x_sent', user_pose.position.x)
            rospy.set_param('/waypoints/y_sent', user_pose.position.y)
            rospy.set_param('/waypoints/z_sent', user_pose.position.z)
            rospy.set_param('/waypoints/x_sent_o', user_pose.orientation.x)
            rospy.set_param('/waypoints/y_sent_o', user_pose.orientation.y)
            rospy.set_param('/waypoints/z_sent_o', user_pose.orientation.z)
            rospy.set_param('/waypoints/w_sent_o', user_pose.orientation.w)

            return errorcode


def main():
    rospy.loginfo('---------------')
    moveit_commander.roscpp_initialize(sys.argv)
    mover = MoveGroupPythonInterface()

    # while not rospy.is_shutdown():
        
        
    # rospy.wait_for_service('reset')
    # reset = rospy.ServiceProxy('reset', SetBool)

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
